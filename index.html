<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paths of Justice - Web Board Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 28px;
      margin-top: 20px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 4px;
      margin: 20px auto;
      width: max-content;
      position: relative;
    }
    .cell {
      background-color: lightgray;
      border: 1px solid #999;
      width: 90px;
      height: 90px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      position: relative;
      flex-direction: column;
      cursor: pointer;
    }
    .player {
      border-radius: 50%;
      width: 20px;
      height: 20px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease-in-out;
      z-index: 10;
    }
    .highlight {
      border: 3px solid yellow !important;
      background-color: rgba(255, 255, 0, 0.3) !important;
    }
    .ladder { background-color: #d4fdd4 !important; }
    .ladder::after {
      content: "üü¢ Good Choice! Move Up";
      position: absolute;
      font-size: 10px;
      bottom: 2px;
      left: 2px;
      color: green;
    }
    .chute { background-color: #fdd4d4 !important; }
    .chute::after {
      content: "üî¥ Bad Choice! Move Down";
      position: absolute;
      font-size: 10px;
      bottom: 2px;
      left: 2px;
      color: red;
    }
    .draw-card { background-color: #d4e3fd !important; position: relative; }
    .draw-card .info-button {
      margin-top: 4px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
    .tooltip-content {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      text-align: left;
      padding: 8px;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
      top: 100%;
      left: 0;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      width: 200px;
    }
    .info-tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .start { background-color: #a8e6ff !important; font-weight: bold; }
    .end { background-color: #b9fbc0 !important; font-weight: bold; }
    .card {
      margin: 20px auto;
      padding: 10px;
      border: 1px solid #333;
      background: #fff;
      max-width: 400px;
      font-size: 14px;
    }
    button {
      margin-top: 10px;
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .player-row {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .info-tooltip {
      position: relative;
      display: inline-block;
    }
    .info-button {
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: none;
    }
    #playerSelection p {
      margin: 10px 0 5px 0;
      font-size: 14px;
    }
    @media (max-width: 600px) {
      #board {
        grid-template-columns: repeat(10, 60px);
        grid-template-rows: repeat(5, 60px);
      }
      .cell {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .player {
        width: 15px;
        height: 15px;
      }
      button {
        font-size: 14px;
        padding: 6px 12px;
      }
      #playerSelection p {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <h1>Paths of Justice</h1>
  <div style="display: flex; justify-content: center; align-items: flex-start; gap: 40px;">
    <div id="playerSelection" style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">
      <h3>Players</h3>
      <div class="player-row">
        <button onclick="game.joinGame(0)" style="background-color: gold;" aria-label="Join as Jaylen">Join as Jaylen üü°</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Jaylen info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Jaylen ‚Äì He‚Äôs trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(1)" style="background-color: red; color: white;" aria-label="Join as Samantha">Join as Samantha üî¥</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Samantha info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Samantha ‚Äì One mistake and now everyone treats her like a criminal. That kind of label sticks and it‚Äôs messing with her future. (Labeling Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(2)" style="background-color: blue; color: white;" aria-label="Join as Marcus">Join as Marcus üîµ</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Marcus info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Marcus ‚Äì All his friends are doing it, and that‚Äôs how he‚Äôs learning what‚Äôs ‚Äúnormal.‚Äù He‚Äôs picking up habits from the people around him. (Social Learning Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(3)" style="background-color: green; color: white;" aria-label="Join as Elena">Join as Elena üü¢</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Elena info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Elena ‚Äì She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)
          </div>
        </div>
      </div>
      <!-- Moved elements here, before the Start Over button -->
      <p>Player positions: <span id="positions">No players</span></p>
      <p id="turnDisplay">üéØ Player 1's turn</p>
      <p id="diceResult"></p>
      <button onclick="game.rollDice()" aria-label="Roll the dice">Roll Dice</button>
      <button onclick="game.resetGame()" aria-label="Start over">Start Over</button>
    </div>
    <div>
      <div id="board" role="grid"></div>
    </div>
  </div>
  <div style="margin-top: 20px;">
    <div class="card" id="card" style="display:none;" role="alert"></div>
  </div>
  <script>
    class Game {
      constructor() {
        this.playerPositions = [1, 1, 1, 1];
        this.currentPlayer = 0;
        this.pendingRoll = null;
        this.targetPosition = null;
        this.activePlayers = [false, false, false, false];
        this.playerColors = ['gold', 'red', 'blue', 'green'];
        this.playerNames = ['Jaylen', 'Samantha', 'Marcus', 'Elena'];
        this.playerDescriptions = [
          'Jaylen ‚Äì He‚Äôs trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)',
          'Samantha ‚Äì One mistake and now everyone treats her like a criminal. That kind of label sticks and it‚Äôs messing with her future. (Labeling Theory)',
          'Marcus ‚Äì All his friends are doing it, and that‚Äôs how he‚Äôs learning what‚Äôs ‚Äúnormal.‚Äù He‚Äôs picking up habits from the people around him. (Social Learning Theory)',
          'Elena ‚Äì She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)'
        ];
        this.board = document.getElementById('board');
        this.positionsDisplay = document.getElementById('positions');
        this.turnDisplay = document.getElementById('turnDisplay');
        this.diceResult = document.getElementById('diceResult');
        this.card = document.getElementById('card');
        this.rollButton = document.querySelector('button[onclick="game.rollDice()"]');
        this.cells = {};
        this.playerTokens = [null, null, null, null];
        this.cellSize = 94; // Cell width/height (90px + 4px gap)
        this.ladders = { 4: 18, 11: 26, 29: 39 };
        this.chutes = { 22: 11, 36: 17, 45: 31 };
        this.cards = {
          6: { text: "You forgot to pay rent and things got rough. Move back 1 space.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 1); } },
          10: { text: "People start calling you a troublemaker. You lose motivation. Go back 3 spaces.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          15: { text: "You meet someone who really believes in you. Move ahead 2 spaces.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          19: { text: "You got profiled by the police for no reason. Go back to space 10.", effect: function (game) { game.playerPositions[game.currentPlayer] = 10; } },
          23: { text: "You do some community service and gain confidence. Move ahead 1 space.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 1); } },
          28: { text: "Your family hits a rough patch. You're distracted. Move back 2.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          33: { text: "You're surrounded by bad influences. You slip up. Move back 1.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 1); } },
          37: { text: "Your wealthy family gets you out of trouble. Move ahead 4.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 4); } },
          42: { text: "You earn a scholarship‚Äîhuge boost! Move ahead 3.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 3); } },
          48: { text: "You're blamed for something you didn‚Äôt do. Move back 3.", effect: function (game) { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } }
        };
      }

      initBoard() {
        try {
          for (let i = 1; i <= 50; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${i}`;
            cell.setAttribute('role', 'gridcell');
            cell.setAttribute('aria-label', `Cell ${i}${this.ladders[i] ? ', ladder' : ''}${this.chutes[i] ? ', chute' : ''}${this.cards[i] ? ', draw card' : ''}`);
            cell.tabIndex = 0;
            cell.dataset.position = i;
            cell.addEventListener('click', () => this.handleCellClick(i));
            this.cells[i] = cell;

            if (i === 1) {
              cell.classList.add('start');
              cell.innerHTML = `<div>1<br>Start Your Future</div>`;
            } else if (i === 50) {
              cell.classList.add('end');
              cell.innerHTML = `<div>50<br>You Made the Right Choices</div>`;
            } else {
              cell.innerHTML = `<div>${i}</div>`;
            }

            if (this.ladders[i]) cell.classList.add('ladder');
            if (this.chutes[i]) cell.classList.add('chute');
            if (this.cards[i]) {
              cell.classList.add('draw-card');
              const wrapper = document.createElement('div');
              wrapper.className = 'info-tooltip';
              const infoButton = document.createElement('button');
              infoButton.className = 'info-button';
              infoButton.textContent = '‚ÑπÔ∏è';
              infoButton.setAttribute('aria-label', `Card info for cell ${i}`);
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = this.cards[i].text;
              wrapper.appendChild(infoButton);
              wrapper.appendChild(tooltip);
              cell.appendChild(wrapper);
            }
            this.board.appendChild(cell);
          }
        } catch (error) {
          console.error('Error in initBoard:', error.message, error.stack);
          alert('Failed to initialize the game board. Please refresh the page.');
        }
      }

      getCellCoordinates(position) {
        const row = Math.floor((position - 1) / 10);
        const col = (position - 1) % 10;
        const x = col * this.cellSize;
        const y = row * this.cellSize;
        return { x, y };
      }

      getTokenOffset(playerIndex, position) {
        const playersAtPosition = this.playerPositions
          .map((pos, idx) => (this.activePlayers[idx] && pos === position ? idx : -1))
          .filter(idx => idx !== -1);
        const playerCount = playersAtPosition.length;
        if (playerCount <= 1) return 0;

        const indexInCell = playersAtPosition.indexOf(playerIndex);
        const offsetStep = 15;
        return (indexInCell - (playerCount - 1) / 2) * offsetStep;
      }

      animateToken(playerIndex, fromPos, toPos) {
        return new Promise(resolve => {
          const token = this.playerTokens[playerIndex];
          if (!token || fromPos === toPos) {
            console.log(`Animation skipped for Player ${playerIndex + 1}: fromPos=${fromPos}, toPos=${toPos}`);
            resolve();
            return;
          }

          const fromCoords = this.getCellCoordinates(fromPos);
          const toCoords = this.getCellCoordinates(toPos);
          const dx = toCoords.x - fromCoords.x;
          const dy = toCoords.y - fromCoords.y;

          const fromOffset = this.getTokenOffset(playerIndex, fromPos);
          const toOffset = this.getTokenOffset(playerIndex, toPos);

          console.log(`Animating Player ${playerIndex + 1} from ${fromPos} to ${toPos}, dx=${dx}, dy=${dy}, fromOffset=${fromOffset}, toOffset=${toOffset}`);

          this.cells[toPos].appendChild(token);

          token.style.transform = `translate(${dx - 50 + fromOffset}%, ${dy - 50}%)`;

          const onTransitionEnd = () => {
            token.removeEventListener('transitionend', onTransitionEnd);
            clearTimeout(timeout);
            token.style.transform = `translate(-50%, -50%) translateX(${toOffset}px)`;
            console.log(`Animation completed for Player ${playerIndex + 1} to position ${toPos}`);
            resolve();
          };

          const timeout = setTimeout(() => {
            token.removeEventListener('transitionend', onTransitionEnd);
            token.style.transform = `translate(-50%, -50%) translateX(${toOffset}px)`;
            console.warn(`Animation timeout for Player ${playerIndex + 1}, forcing completion to position ${toPos}`);
            resolve();
          }, 1000);

          token.addEventListener('transitionend', onTransitionEnd, { once: true });
        });
      }

      async renderPlayer() {
        try {
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index] && !this.playerTokens[index]) {
              const token = document.createElement('div');
              token.className = 'player';
              token.style.backgroundColor = this.playerColors[index];
              token.title = `${this.playerNames[index]} (Player ${index + 1})`;
              token.setAttribute('aria-label', `${this.playerNames[index]} at position ${pos}`);
              this.cells[pos].appendChild(token);
              this.playerTokens[index] = token;
            }
          });

          let positionsText = '';
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index]) {
              const token = this.playerTokens[index];
              if (token && token.parentNode !== this.cells[pos]) {
                this.cells[pos].appendChild(token);
              }
              const offset = this.getTokenOffset(index, pos);
              token.style.transform = `translate(-50%, -50%) translateX(${offset}px)`;
              positionsText += `${this.playerNames[index]}: ${pos} | `;
            }
          });
          this.positionsDisplay.textContent = positionsText ? positionsText.slice(0, -3) : 'No players';
        } catch (error) {
          console.error('Error in renderPlayer:', error.message, error.stack);
          alert('Failed to render players. Please reset the game.');
        }
      }

      updateButtonState() {
        const hasPlayers = this.activePlayers.includes(true);
        this.rollButton.disabled = !hasPlayers;
      }

      joinGame(playerIndex) {
        try {
          if (this.activePlayers[playerIndex]) {
            alert(`${this.playerNames[playerIndex]} has already joined.`);
            return;
          }
          this.activePlayers[playerIndex] = true;
          alert(`${this.playerNames[playerIndex]} joined the game!\n\n${this.playerDescriptions[playerIndex]}`);
          this.renderPlayer();
          this.updateButtonState();
          if (this.currentPlayer === playerIndex && !this.activePlayers[this.currentPlayer]) {
            this.nextTurn();
          }
        } catch (error) {
          console.error('Error in joinGame:', error.message, error.stack);
          alert('Failed to join the game. Please refresh the page.');
        }
      }

      clearHighlights() {
        Object.values(this.cells).forEach(cell => {
          cell.classList.remove('highlight');
        });
      }

      highlightTargetCell(position) {
        this.clearHighlights();
        if (this.cells[position]) {
          this.cells[position].classList.add('highlight');
        }
      }

      rollDice() {
        try {
          if (!this.activePlayers.includes(true)) {
            alert('No players have joined the game!');
            return;
          }
          this.card.style.display = 'none';
          const roll = Math.floor(Math.random() * 6) + 1;
          this.pendingRoll = roll;
          this.diceResult.textContent = `üé≤ Rolled: ${roll}. Click on the highlighted cell to move!`;
          const currentPos = this.playerPositions[this.currentPlayer];
          this.targetPosition = Math.min(50, currentPos + roll);
          this.highlightTargetCell(this.targetPosition);
        } catch (error) {
          console.error('Error in rollDice:', error.message, error.stack);
          alert('Failed to roll the dice. Please reset the game.');
        }
      }

      async handleCellClick(position) {
        if (this.pendingRoll === null) {
          alert('Please roll the dice first!');
          return;
        }

        if (position !== this.targetPosition) {
          alert(`You must move to cell ${this.targetPosition}!`);
          return;
        }

        try {
          console.log(`Player ${this.currentPlayer + 1} clicked cell ${position}`);
          
          const currentPos = this.playerPositions[this.currentPlayer];
          let nextPos = position;

          await this.animateToken(this.currentPlayer, currentPos, nextPos);
          this.playerPositions[this.currentPlayer] = nextPos;

          if (this.ladders[nextPos]) {
            const ladderPos = this.ladders[nextPos];
            alert('üü¢ You climbed a ladder! Moving to position ' + ladderPos + '!');
            await this.animateToken(this.currentPlayer, nextPos, ladderPos);
            nextPos = ladderPos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }
          else if (this.chutes[nextPos]) {
            const chutePos = this.chutes[nextPos];
            alert('üî¥ You slid down a chute! Moving to position ' + chutePos + '!');
            await this.animateToken(this.currentPlayer, nextPos, chutePos);
            nextPos = chutePos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.cards[nextPos]) {
            const cardData = this.cards[nextPos];
            console.log(`Card effect at position ${nextPos}: ${cardData.text}`);
            const prevPos = this.playerPositions[this.currentPlayer];
            cardData.effect(this);
            const newPos = this.playerPositions[this.currentPlayer];
            console.log(`After card effect, Player ${this.currentPlayer + 1} moved from ${nextPos} to ${newPos}`);
            
            alert(`${cardData.text}\nYou moved to position ${newPos}!`);

            if (newPos !== nextPos) {
              await this.animateToken(this.currentPlayer, nextPos, newPos);
              this.playerPositions[this.currentPlayer] = newPos;
              await this.renderPlayer();
            } else {
              console.log(`No position change after card effect, proceeding`);
              await new Promise(resolve => setTimeout(resolve, 300));
            }
            this.card.textContent = cardData.text;
            this.card.style.display = 'block';
          } else {
            this.card.style.display = 'none';
          }

          if (this.playerPositions[this.currentPlayer] >= 50) {
            alert(`${this.playerNames[this.currentPlayer]} wins!`);
            this.playerTokens[this.currentPlayer].remove();
            this.playerTokens[this.currentPlayer] = null;
            this.activePlayers[this.currentPlayer] = false;
            if (!this.activePlayers.includes(true)) {
              alert('Game Over! All players have finished.');
              this.resetGame();
              return;
            }
          }

          await this.renderPlayer();
          this.pendingRoll = null;
          this.targetPosition = null;
          this.clearHighlights();
          this.diceResult.textContent = `üé≤ Rolled: --`;
          this.nextTurn();
        } catch (error) {
          console.error('Error in handleCellClick:', error.message, error.stack);
          alert('An error occurred during the move. Please reset the game.');
        }
      }

      nextTurn() {
        try {
          do {
            this.currentPlayer = (this.currentPlayer + 1) % 4;
          } while (!this.activePlayers[this.currentPlayer] && this.activePlayers.includes(true));
          this.turnDisplay.textContent = `üéØ ${this.playerNames[this.currentPlayer]}'s turn (Player ${this.currentPlayer + 1})`;
          this.updateButtonState();
        } catch (error) {
          console.error('Error in nextTurn:', error.message, error.stack);
          alert('Failed to advance to the next turn. Please reset the game.');
        }
      }

      resetGame() {
        try {
          this.playerPositions = [1, 1, 1, 1];
          this.currentPlayer = 0;
          this.pendingRoll = null;
          this.targetPosition = null;
          this.activePlayers = [false, false, false, false];
          this.playerTokens.forEach(token => token?.remove());
          this.playerTokens = [null, null, null, null];
          this.clearHighlights();
          this.renderPlayer();
          this.card.style.display = 'none';
          this.diceResult.textContent = '';
          this.turnDisplay.textContent = 'üéØ Player 1\'s turn';
          this.updateButtonState();
        } catch (error) {
          console.error('Error in resetGame:', error.message, error.stack);
          alert('Failed to reset the game. Please refresh the page.');
        }
      }
    }

    window.onload = function () {
      try {
        const game = new Game();
        game.initBoard();
        window.game = game;
        game.renderPlayer();
        game.updateButtonState();
      } catch (error) {
        console.error('Error on window.onload:', error.message, error.stack);
        alert('Failed to initialize the game. Please refresh the page.');
      }
    };
  </script>
</body>
</html>
