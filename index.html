<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paths of Justice - Web Board Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 28px;
      margin-top: 20px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 4px;
      margin: 20px auto;
      width: max-content;
      position: relative;
      min-height: 470px;
    }
    .cell {
      background-color: lightgray;
      border: 1px solid #999;
      width: 90px;
      height: 90px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      position: relative;
      flex-direction: column;
      cursor: pointer;
    }
    .player {
      border-radius: 50%;
      width: 20px;
      height: 20px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease-in-out;
      z-index: 10;
    }
    .highlight {
      border: 3px solid yellow !important;
      background-color: rgba(255, 255, 0, 0.3) !important;
    }
    .ladder { background-color: #d4fdd4 !important; position: relative; }
    .ladder .ladder-label {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      font-weight: bold;
      color: green;
      text-align: left;
      width: 80px;
      line-height: 12px;
    }
    .chute { background-color: #fdd4d4 !important; position: relative; }
    .chute .chute-label {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      font-weight: bold;
      color: red;
      text-align: left;
      width: 80px;
      line-height: 12px;
    }
    .draw-card { background-color: #d4e3fd !important; position: relative; }
    .draw-card .info-button {
      margin-top: 4px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 10px;
      color: #333;
      padding: 2px 4px;
      font-weight: bold;
    }
    .trouble { background-color: #ffcccb !important; position: relative; }
    .trouble img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .tooltip-content {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      text-align: left;
      padding: 8px;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
      top: 100%;
      left: 0;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      width: 200px;
    }
    .info-tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .chute:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .ladder:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .trouble:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .start { background-color: #a8e6ff !important; }
    .end { background-color: #b9fbc0 !important; }
    .card {
      margin: 20px auto;
      padding: 10px;
      border: 1px solid #333;
      background: #fff;
      max-width: 400px;
      font-size: 14px;
    }
    button {
      margin-top: 10px;
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .player-row {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .info-tooltip {
      position: relative;
      display: inline-block;
    }
    .info-button {
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: none;
    }
    #playerSelection p {
      margin: 10px 0 5px 0;
      font-size: 14px;
    }
    #positionsDisplay {
      margin: 10px auto;
      font-size: 14px;
      max-width: 900px;
      text-align: center;
    }
    #loading {
      margin: 20px;
      font-size: 18px;
      color: #333;
    }
    #gameModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    #gameModalContent {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      text-align: left;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    #gameModalContent h3 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }
    #gameModalContent p {
      margin: 0 0 20px 0;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .modal-buttons button {
      padding: 8px 16px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .modal-button-ok {
      background-color: #2196F3;
      color: white;
    }
    .modal-button-join {
      background-color: #4CAF50;
      color: white;
    }
    .modal-button-cancel {
      background-color: #f44336;
      color: white;
    }
    /* New styles for victory pop-up */
    #victoryModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 200;
      justify-content: center;
      align-items: center;
    }
    #victoryModalContent {
      background-color: #fff;
      padding: 30px;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      border: 3px solid #4CAF50;
    }
    #victoryModalContent h2 {
      margin: 0 0 20px 0;
      font-size: 28px;
      color: #4CAF50;
      text-transform: uppercase;
    }
    #victoryModalContent p {
      font-size: 18px;
      margin: 0 0 20px 0;
      line-height: 1.5;
      color: #333;
    }
    #victoryModalContent img {
      width: 100%;
      max-width: 300px;
      height: auto;
      margin: 20px 0;
      border-radius: 8px;
    }
    .victory-button {
      background-color: #4CAF50;
      color: white;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .victory-button:hover {
      background-color: #45a049;
    }
    #diceDisplay {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    .dice {
      width: 100px;
      height: 100px;
      background-color: white;
      border: 2px solid black;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      padding: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    .dot {
      width: 20px;
      height: 20px;
      background-color: black;
      border-radius: 50%;
      place-self: center;
      display: none;
    }
    .dice-1 .dot:nth-child(1) { display: block; grid-column: 2; grid-row: 2; }
    .dice-2 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-2 .dot:nth-child(2) { display: block; grid-column: 3; grid-row: 3; }
    .dice-3 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-3 .dot:nth-child(2) { display: block; grid-column: 2; grid-row: 2; }
    .dice-3 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 3; }
    .dice-4 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-4 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 3; }
    .dice-4 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 1; }
    .dice-4 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 3; }
    .dice-5 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-5 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 3; }
    .dice-5 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 1; }
    .dice-5 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 3; }
    .dice-5 .dot:nth-child(5) { display: block; grid-column: 2; grid-row: 2; }
    .dice-6 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-6 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 2; }
    .dice-6 .dot:nth-child(3) { display: block; grid-column: 1; grid-row: 3; }
    .dice-6 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 1; }
    .dice-6 .dot:nth-child(5) { display: block; grid-column: 3; grid-row: 2; }
    .dice-6 .dot:nth-child(6) { display: block; grid-column: 3; grid-row: 3; }
    .start img, .end img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    @media (max-width: 600px) {
      #board {
        grid-template-columns: repeat(10, 60px);
        grid-template-rows: repeat(5, 60px);
        min-height: 310px;
      }
      .cell {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .player {
        width: 15px;
        height: 15px;
      }
      button {
        font-size: 14px;
        padding: 6px 12px;
      }
      #playerSelection p {
        font-size: 12px;
      }
      #positionsDisplay {
        font-size: 12px;
      }
      #gameModalContent {
        padding: 15px;
      }
      #gameModalContent h3 {
        font-size: 16px;
      }
      #gameModalContent p {
        font-size: 12px;
      }
      .modal-buttons button {
        font-size: 12px;
        padding: 6px 12px;
      }
      .chute-label, .ladder-label {
        font-size: 8px;
        width: 50px;
      }
      .draw-card .info-button {
        font-size: 8px;
        padding: 1px 2px;
      }
      .dice {
        width: 60px;
        height: 60px;
        padding: 5px;
      }
      .dot {
        width: 12px;
        height: 12px;
      }
      #victoryModalContent {
        padding: 20px;
        max-width: 90%;
      }
      #victoryModalContent h2 {
        font-size: 20px;
      }
      #victoryModalContent p {
        font-size: 14px;
      }
      #victoryModalContent img {
        max-width: 200px;
      }
      .victory-button {
        padding: 10px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <h1>Paths of Justice</h1>
  <div id="loading">Loading...</div>
  <div style="display: flex; justify-content: center; align-items: flex-start; gap: 40px;">
    <div id="playerSelection" style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">
      <h3>Players</h3>
      <div class="player-row">
        <button onclick="game.joinGame(0)" style="background-color: gold;" aria-label="Join as Jaylen">Join as Jaylen 🟡</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Jaylen info">ℹ️</button>
          <div class="tooltip-content">
            Jaylen – He’s trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(1)" style="background-color: red; color: white;" aria-label="Join as Samantha">Join as Samantha 🔴</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Samantha info">ℹ️</button>
          <div class="tooltip-content">
            Samantha – One mistake and now everyone treats her like a criminal. That kind of label sticks and it’s messing with her future. (Labeling Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(2)" style="background-color: blue; color: white;" aria-label="Join as Marcus">Join as Marcus 🔵</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Marcus info">ℹ️</button>
          <div class="tooltip-content">
            Marcus – All his friends are doing it, and that’s how he’s learning what’s “normal.” He’s picking up habits from the people around him. (Social Learning Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(3)" style="background-color: green; color: white;" aria-label="Join as Elena">Join as Elena 🟢</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Elena info">ℹ️</button>
          <div class="tooltip-content">
            Elena – She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)
          </div>
        </div>
      </div>
      <p id="turnDisplay">🎯 Player 1's turn</p>
      <p id="diceResult"></p>
      <button id="rollDiceButton" onclick="game.rollDice()" aria-label="Roll the dice for current player">Player 1 Roll Dice</button>
      <button onclick="game.resetGame()" aria-label="Start over">Start Over</button>
    </div>
    <div>
      <div id="board" role="grid" aria-live="polite"></div>
      <p id="positionsDisplay">Player positions: <span id="positions">No players</span></p>
    </div>
  </div>
  <div id="diceDisplay">
    <div class="dice">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  <div style="margin-top: 20px;">
    <div class="card" id="card" style="display:none;" role="alert"></div>
  </div>
  <div id="gameModal" role="dialog" aria-labelledby="gameModalTitle" aria-modal="true">
    <div id="gameModalContent">
      <h3 id="gameModalTitle"></h3>
      <p id="gameModalDescription"></p>
      <div class="modal-buttons" id="gameModalButtons"></div>
    </div>
  </div>
  <!-- New victory modal -->
  <div id="victoryModal" role="dialog" aria-labelledby="victoryModalTitle" aria-modal="true">
    <div id="victoryModalContent">
      <h2 id="victoryModalTitle"></h2>
      <p id="victoryModalDescription"></p>
      <img src="https://media.giphy.com/media/xUOwFUnsoHbFLn16eY/giphy.gif" alt="Continue Your Journey GIF">
      <button class="victory-button" onclick="game.closeVictoryModal()" aria-label="Continue">Continue</button>
    </div>
  </div>
  <script>
    class Game {
      constructor() {
        console.log('Game constructor called');
        this.board = document.getElementById('board');
        if (!this.board) {
          console.error('Board element not found!');
          this.showModal('Error', 'Game board not found. Please check the HTML.');
          return;
        }
        this.playerPositions = [1, 1, 1, 1];
        this.currentPlayer = 0;
        this.pendingRoll = null;
        this.targetPosition = null;
        this.activePlayers = [false, false, false, false];
        this.playerColors = ['gold', 'red', 'blue', 'green'];
        this.playerTextColors = ['black', 'white', 'white', 'white'];
        this.playerNames = ['Jaylen', 'Samantha', 'Marcus', 'Elena'];
        this.playerDescriptions = [
          'Jaylen – He’s trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)',
          'Samantha – One mistake and now everyone treats her like a criminal. That kind of label sticks and it’s messing with her future. (Labeling Theory)',
          'Marcus – All his friends are doing it, and that’s how he’s learning what’s “normal.” He’s picking up habits from the people around him. (Social Learning Theory)',
          'Elena – She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)'
        ];
        this.positionsDisplay = document.getElementById('positions');
        this.turnDisplay = document.getElementById('turnDisplay');
        this.diceResult = document.getElementById('diceResult');
        this.diceDisplay = document.getElementById('diceDisplay');
        this.card = document.getElementById('card');
        this.rollButton = document.getElementById('rollDiceButton');
        this.cells = {};
        this.playerTokens = [null, null, null, null];
        this.cellSize = 94;
        this.ladders = {
          4: { to: 18, label: "Strain Theory Ladder to 18", message: "🟢 Strain Theory: You found a mentor who helped you overcome life's pressures—climb up to 18!" },
          11: { to: 26, label: "Labeling Theory Ladder to 26", message: "🟢 Labeling Theory: You worked hard to break free from a negative label and gained support—climb up to 26!" },
          29: { to: 39, label: "Social Learning Ladder to 39", message: "🟢 Social Learning Theory: You learned positive habits from a role model—climb up to 39!" },
          42: { to: 48, label: "Conflict Theory Ladder to 48", message: "🟢 Conflict Theory: You advocated for change and gained allies in the system—climb up to 48!" }
        };
        this.chutes = {
          25: { to: 14, label: "Strain Theory Chute to 14", message: "🔴 Strain Theory: You felt overwhelmed by life's pressures and made a desperate choice to get ahead. It backfired—slide down to 14!" },
          30: { to: 20, label: "Labeling Theory Chute to 20", message: "🔴 Labeling Theory: Society labeled you as a troublemaker after a small mistake, and the stigma made you slip up again—slide down to 20!" },
          40: { to: 28, label: "Social Learning Chute to 28", message: "🔴 Social Learning Theory: You copied a risky behavior from those around you, thinking it was okay. Wrong move—slide down to 28!" },
          47: { to: 35, label: "Conflict Theory Chute to 35", message: "🔴 Conflict Theory: The system treated you unfairly because of your background, setting you up to fail—slide down to 35!" }
        };
        this.troubleSlots = {
          17: { to: 1, message: "🔴 Social Learning Theory: You saw your friends spray painting and thought it was okay, but you got caught! Go back to the start line." },
          31: { to: 1, message: "🔴 Labeling Theory: You were labeled a troublemaker after spray painting, leading to more trouble! Go back to the start line." }
        };
        this.cardPool = [
          { theory: "Strain Theory", text: "A mentor helps you manage stress from life's pressures. Move forward 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 3); } },
          { theory: "Strain Theory", text: "You secure a part-time job to ease financial strain. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Strain Theory", text: "The pressure to succeed leads you to a risky decision. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Strain Theory", text: "Financial strain causes you to miss an opportunity. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Labeling Theory", text: "You prove the negative labels wrong and gain community support. Move forward 4 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 4); } },
          { theory: "Labeling Theory", text: "A teacher sees your potential beyond the labels. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Labeling Theory", text: "Society's labels make you doubt yourself, causing a setback. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Labeling Theory", text: "A false label leads to unfair treatment. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Social Learning Theory", text: "You learn a valuable skill from a positive role model. Move forward 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 3); } },
          { theory: "Social Learning Theory", text: "A friend inspires you to make better choices. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Social Learning Theory", text: "You pick up a bad habit from peers. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Social Learning Theory", text: "Negative influences lead you astray. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Conflict Theory", text: "You organize a protest and gain allies against an unfair system. Move forward 4 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 4); } },
          { theory: "Conflict Theory", text: "A community leader helps you navigate systemic barriers. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Conflict Theory", text: "Systemic inequality blocks your progress. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Conflict Theory", text: "Unfair treatment by authorities sets you back. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Strain Theory", text: "You join a community program that helps you cope with life’s pressures, giving you a major boost toward your goals. Move forward 6 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 6); } },
          { theory: "Labeling Theory", text: "A past label resurfaces, causing authorities to unfairly target you again. Move back 5 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 5); } },
          { theory: "Conflict Theory", text: "You lead a movement against systemic inequality, gaining widespread support and momentum. Move forward 7 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 7); } }
        ];
        this.cardCells = [6, 10, 15, 19, 23, 28, 33, 37, 48];
        this.currentJoinIndex = null;
        this.isProcessingMove = false;
        this.initModalElements();
        this.setupEventListeners();
        this.updateRollButtonLabel();
      }

      initModalElements() {
        console.log('Initializing modal elements...');
        this.gameModal = document.getElementById('gameModal');
        this.gameModalTitle = document.getElementById('gameModalTitle');
        this.gameModalDescription = document.getElementById('gameModalDescription');
        this.gameModalButtons = document.getElementById('gameModalButtons');
        this.victoryModal = document.getElementById('victoryModal');
        this.victoryModalTitle = document.getElementById('victoryModalTitle');
        this.victoryModalDescription = document.getElementById('victoryModalDescription');
        if (!this.gameModal || !this.gameModalTitle || !this.gameModalDescription || !this.gameModalButtons ||
            !this.victoryModal || !this.victoryModalTitle || !this.victoryModalDescription) {
          console.error('Modal elements not found!');
          document.getElementById('loading').textContent = 'Error: Modal elements not found.';
        }
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.gameModal && this.gameModal.style.display === 'flex') {
            this.gameModal.style.display = 'none';
            this.currentJoinIndex = null;
          }
          if (e.key === 'Escape' && this.victoryModal && this.victoryModal.style.display === 'flex') {
            this.closeVictoryModal();
          }
        });

        if (this.gameModal) {
          this.gameModal.addEventListener('click', (e) => {
            if (e.target === this.gameModal) {
              this.gameModal.style.display = 'none';
              this.currentJoinIndex = null;
            }
          });
        }

        if (this.victoryModal) {
          this.victoryModal.addEventListener('click', (e) => {
            if (e.target === this.victoryModal) {
              this.closeVictoryModal();
            }
          });
        }
      }

      showModal(title, message, buttons = [{ text: 'OK', class: 'modal-button-ok', onClick: () => this.gameModal.style.display = 'none' }]) {
        if (!this.gameModal || !this.gameModalTitle || !this.gameModalDescription || !this.gameModalButtons) {
          console.error('Cannot show modal: modal elements not initialized');
          document.getElementById('loading').textContent = 'Error: Cannot display modal.';
          return;
        }
        this.gameModalTitle.textContent = title;
        this.gameModalDescription.textContent = message;
        this.gameModalButtons.innerHTML = '';

        buttons.forEach(button => {
          const btn = document.createElement('button');
          btn.textContent = button.text;
          btn.className = button.class;
          btn.setAttribute('aria-label', button.text);
          btn.addEventListener('click', () => {
            button.onClick();
          });
          this.gameModalButtons.appendChild(btn);
        });

        this.gameModal.style.display = 'flex';
        this.gameModalButtons.querySelector('button').focus();
      }

      showVictoryModal(playerName) {
        if (!this.victoryModal || !this.victoryModalTitle || !this.victoryModalDescription) {
          console.error('Cannot show victory modal: modal elements not initialized');
          document.getElementById('loading').textContent = 'Error: Cannot display victory modal.';
          return;
        }
        this.victoryModalTitle.textContent = `${playerName} Wins!`;
        this.victoryModalDescription.textContent = 'You have won the game, but your journey is up to you. Continue your journey.';
        this.victoryModal.style.display = 'flex';
        this.victoryModal.querySelector('.victory-button').focus();
      }

      closeVictoryModal() {
        if (this.victoryModal) {
          this.victoryModal.style.display = 'none';
        }
      }

      initBoard() {
        console.log('Initializing board...');
        try {
          document.getElementById('loading').style.display = 'none';
          this.board.innerHTML = '';
          this.cells = {};

          for (let i = 1; i <= 50; i++) {
            console.log(`Creating cell ${i}`);
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${i}`;
            cell.setAttribute('role', 'gridcell');
            const troubleMessage = this.troubleSlots[i] ? `, ${this.troubleSlots[i].message}` : '';
            cell.setAttribute('aria-label', `Cell ${i}${this.ladders[i] ? ', ladder' : ''}${this.chutes[i] ? ', chute' : ''}${this.cardCells.includes(i) ? ', draw card' : ''}${this.troubleSlots[i] ? ', trouble' + troubleMessage : ''}`);
            cell.tabIndex = 0;
            cell.dataset.position = i;
            cell.removeEventListener('click', this.handleCellClickBound);
            cell.addEventListener('click', () => this.handleCellClick(i));
            this.cells[i] = cell;

            if (i === 1) {
              cell.classList.add('start');
              cell.innerHTML = `<img src="https://media.giphy.com/media/27njMqCBPc2SQ/giphy.gif" alt="Start Line">`;
            } else if (i === 50) {
              cell.classList.add('end');
              cell.innerHTML = `<img src="https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif" alt="Finish Line">`;
            } else if (i === 17 || i === 31) {
              cell.classList.add('trouble');
              const troubleData = this.troubleSlots[i];
              cell.innerHTML = `<img src="https://media.giphy.com/media/4GMtanwbPY0xSpy2V5/giphy.gif" alt="Trouble: Spray Paint">`;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = troubleData.message;
              cell.appendChild(tooltip);
            } else {
              cell.innerHTML = `<div>${i}</div>`;
            }

            if (this.ladders[i]) {
              cell.classList.add('ladder');
              const ladderData = this.ladders[i];
              const label = document.createElement('div');
              label.className = 'ladder-label';
              label.textContent = ladderData.label;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = ladderData.message;
              cell.appendChild(label);
              cell.appendChild(tooltip);
            }
            if (this.chutes[i]) {
              cell.classList.add('chute');
              const chuteData = this.chutes[i];
              const label = document.createElement('div');
              label.className = 'chute-label';
              label.textContent = chuteData.label;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = chuteData.message;
              cell.appendChild(label);
              cell.appendChild(tooltip);
            }
            if (this.cardCells.includes(i)) {
              cell.classList.add('draw-card');
              const wrapper = document.createElement('div');
              wrapper.className = 'info-tooltip';
              const infoButton = document.createElement('button');
              infoButton.className = 'info-button';
              infoButton.textContent = 'Draw a Card';
              infoButton.setAttribute('aria-label', `Card info for cell ${i}`);
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = 'Draw a Card';
              wrapper.appendChild(infoButton);
              wrapper.appendChild(tooltip);
              cell.appendChild(wrapper);
            }
            this.board.appendChild(cell);
          }
        } catch (error) {
          console.error('Error in initBoard:', error.message, error.stack);
          document.getElementById('loading').textContent = 'Error: Failed to initialize the game board.';
          this.showModal('Error', 'Failed to initialize the game board. Please refresh the page.');
        }
      }

      drawRandomCard() {
        const randomIndex = Math.floor(Math.random() * this.cardPool.length);
        return this.cardPool[randomIndex];
      }

      getCellCoordinates(position) {
        const row = Math.floor((position - 1) / 10);
        const col = (position - 1) % 10;
        const x = col * this.cellSize;
        const y = row * this.cellSize;
        return { x, y };
      }

      getTokenOffset(playerIndex, position) {
        const playersAtPosition = this.playerPositions
          .map((pos, idx) => (this.activePlayers[idx] && pos === position ? idx : -1))
          .filter(idx => idx !== -1);
        const playerCount = playersAtPosition.length;
        if (playerCount <= 1) return 0;

        const indexInCell = playersAtPosition.indexOf(playerIndex);
        const offsetStep = window.innerWidth <= 600 ? 10 : 15;
        return (indexInCell - (playerCount - 1) / 2) * offsetStep;
      }

      animateToken(playerIndex, fromPos, toPos) {
        return new Promise(resolve => {
          const token = this.playerTokens[playerIndex];
          if (!token || fromPos === toPos) {
            resolve();
            return;
          }
          this.cells[toPos].appendChild(token);
          const offset = this.getTokenOffset(playerIndex, toPos);
          token.style.transform = `translate(-50%, -50%) translateX(${offset}px)`;
          setTimeout(resolve, 300);
        });
      }

      async renderPlayer() {
        try {
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index] && !this.playerTokens[index]) {
              const token = document.createElement('div');
              token.className = 'player';
              token.style.backgroundColor = this.playerColors[index];
              token.title = `${this.playerNames[index]} (Player ${index + 1})`;
              token.setAttribute('aria-label', `${this.playerNames[index]} at position ${pos}`);
              this.cells[pos].appendChild(token);
              this.playerTokens[index] = token;
            }
          });

          let positionsText = '';
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index]) {
              const token = this.playerTokens[index];
              if (token && token.parentNode !== this.cells[pos]) {
                this.cells[pos].appendChild(token);
              }
              const offset = this.getTokenOffset(index, pos);
              token.style.transform = `translate(-50%, -50%) translateX(${offset}px)`;
              positionsText += `${this.playerNames[index]}: ${pos} | `;
            }
          });
          this.positionsDisplay.textContent = positionsText ? positionsText.slice(0, -3) : 'No players';
        } catch (error) {
          console.error('Error in renderPlayer:', error.message, error.stack);
          this.showModal('Error', 'Failed to render players. Please reset the game.');
        }
      }

      updateButtonState() {
        const hasPlayers = this.activePlayers.includes(true);
        this.rollButton.disabled = !hasPlayers;
      }

      updateRollButtonLabel() {
        if (this.activePlayers[this.currentPlayer]) {
          this.rollButton.textContent = `${this.playerNames[this.currentPlayer]} Roll Dice`;
          this.rollButton.setAttribute('aria-label', `Roll the dice for ${this.playerNames[this.currentPlayer]}`);
          this.rollButton.style.backgroundColor = this.playerColors[this.currentPlayer];
          this.rollButton.style.color = this.playerTextColors[this.currentPlayer];
        } else {
          this.rollButton.textContent = 'Player Roll Dice';
          this.rollButton.setAttribute('aria-label', 'Roll the dice for current player');
          this.rollButton.style.backgroundColor = '';
          this.rollButton.style.color = '';
        }
      }

      joinGame(playerIndex) {
        try {
          if (this.activePlayers[playerIndex]) {
            this.showModal('Notice', `${this.playerNames[playerIndex]} has already joined.`);
            return;
          }

          this.currentJoinIndex = playerIndex;
          this.showModal(
            `${this.playerNames[playerIndex]}'s Profile`,
            this.playerDescriptions[playerIndex],
            [
              {
                text: 'Cancel',
                class: 'modal-button-cancel',
                onClick: () => {
                  this.gameModal.style.display = 'none';
                  this.currentJoinIndex = null;
                }
              },
              {
                text: 'Join',
                class: 'modal-button-join',
                onClick: () => {
                  this.activePlayers[playerIndex] = true;
                  this.renderPlayer();
                  this.updateButtonState();
                  if (this.currentPlayer === playerIndex && !this.gameModal.style.display = 'none';
                  this.currentJoinIndex = null;
                }
              }
            ]
          );
        } catch (error) {
          console.error('Error in joinGame:', error.message, error.stack);
          this.showModal('Error', 'Failed to join the game. Please refresh the page.');
        }
      }

      clearHighlights() {
        Object.values(this.cells).forEach(cell => {
          cell.classList.remove('highlight');
        });
      }

      highlightTargetCell(position) {
        this.clearHighlights();
        if (this.cells[position]) {
          this.cells[position].classList.add('highlight');
        }
      }

      showDice(roll) {
        const diceElement = this.diceDisplay.querySelector('.dice');
        diceElement.className = 'dice';
        diceElement.classList.add(`dice-${roll}`);
        this.diceDisplay.style.display = 'block';
        setTimeout(() => {
          this.diceDisplay.style.opacity = '1';
        }, 10);
      }

      hideDice() {
        this.diceDisplay.style.opacity = '0';
        setTimeout(() => {
          this.diceDisplay.style.display = 'none';
        }, 500);
      }

      async rollDice() {
        try {
          if (!this.activePlayers.includes(true)) {
            this.showModal('Notice', 'No players have joined the game!');
            return;
          }
          this.card.style.display = 'none';
          this.hideDice();
          const roll = Math.floor(Math.random() * 6) + 1;
          this.pendingRoll = roll;
          this.showDice(roll);
          await new Promise(resolve => setTimeout(resolve, 2000));
          this.diceResult.textContent = `Click on the highlighted cell to move!`;
          const currentPos = this.playerPositions[this.currentPlayer];
          this.targetPosition = Math.min(50, currentPos + roll);
          this.highlightTargetCell(this.targetPosition);
          console.log(`Rolled dice: ${roll}, Current Position: ${currentPos}, Target Position: ${this.targetPosition}, Pending Roll: ${this.pendingRoll}`);
        } catch (error) {
          console.error('Error in rollDice:', error.message, error.stack);
          this.showModal('Error', 'Failed to roll the dice. Please reset the game.');
        }
      }

      async handleCellClick(position) {
        console.log(`handleCellClick called with position: ${position}, Pending Roll: ${this.pendingRoll}, Target Position: ${this.targetPosition}`);
        
        if (this.isProcessingMove) {
          console.log('Move is already being processed, ignoring click');
          return;
        }

        if (this.pendingRoll === null) {
          console.log('Pending roll is null, showing "Please roll the dice first!" message');
          this.showModal('Notice', 'Please roll the dice first!');
          return;
        }

        if (position !== this.targetPosition) {
          console.log(`Clicked position ${position} does not match target position ${this.targetPosition}`);
          this.showModal('Notice', `You must move to cell ${this.targetPosition}!`);
          return;
        }

        this.isProcessingMove = true;
        try {
          console.log(`Player ${this.currentPlayer + 1} clicked cell ${position}`);
          
          const currentPos = this.playerPositions[this.currentPlayer];
          let nextPos = position;

          await this.animateToken(this.currentPlayer, currentPos, nextPos);
          this.playerPositions[this.currentPlayer] = nextPos;

          if (this.ladders[nextPos]) {
            const ladderData = this.ladders[nextPos];
            const ladderPos = ladderData.to;
            this.showModal('Ladder!', `${ladderData.message}\nMoving to position ${ladderPos}!`);
            await this.animateToken(this.currentPlayer, nextPos, ladderPos);
            nextPos = ladderPos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.chutes[nextPos]) {
            const chuteData = this.chutes[nextPos];
            const chutePos = chuteData.to;
            this.showModal('Chute!', `${chuteData.message}\nMoving to position ${chutePos}!`);
            await this.animateToken(this.currentPlayer, nextPos, chutePos);
            nextPos = chutePos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.cardCells.includes(nextPos)) {
            const cardData = this.drawRandomCard();
            console.log(`Drew card at position ${nextPos}: ${cardData.text}`);
            const prevPos = this.playerPositions[this.currentPlayer];
            cardData.effect(this);
            const newPos = this.playerPositions[this.currentPlayer];
            console.log(`After card effect, Player ${this.currentPlayer + 1} moved from ${nextPos} to ${newPos}`);
            
            const displayText = `${cardData.theory}: ${cardData.text}`;
            this.showModal('Action Card', `${displayText}\nYou moved to position ${newPos}!`);

            if (newPos !== nextPos) {
              await this.animateToken(this.currentPlayer, nextPos, newPos);
              nextPos = newPos;
              this.playerPositions[this.currentPlayer] = nextPos;
            } else {
              console.log(`No position change after card effect, proceeding`);
              await new Promise(resolve => setTimeout(resolve, 300));
            }
            this.card.textContent = displayText;
            this.card.style.display = 'block';
          } else {
            this.card.style.display = 'none';
          }

          if (this.troubleSlots[nextPos]) {
            const troubleData = this.troubleSlots[nextPos];
            const troublePos = troubleData.to;
            this.showModal('Trouble!', `${troubleData.message}\nMoving to position ${troublePos}!`);
            await this.animateToken(this.currentPlayer, nextPos, troublePos);
            nextPos = troublePos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.playerPositions[this.currentPlayer] >= 50) {
            this.showVictoryModal(this.playerNames[this.currentPlayer]);
            this.playerTokens[this.currentPlayer].remove();
            this.playerTokens[this.currentPlayer] = null;
            this.activePlayers[this.currentPlayer] = false;
            await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to ensure modal displays
            if (!this.activePlayers.includes(true)) {
              this.showModal('Game Over', 'Game Over! All players have finished.', [
                {
                  text: 'OK',
                  class: 'modal-button-ok',
                  onClick: () => {
                    this.gameModal.style.display = 'none';
                    this.resetGame();
                  }
                }
              ]);
              return;
            }
          }

          await this.renderPlayer();
          this.pendingRoll = null;
          this.targetPosition = null;
          this.hideDice();
          this.clearHighlights();
          this.diceResult.textContent = `🎲 Rolled: --`;
          console.log('After move, reset Pending Roll and Target Position');
          this.nextTurn();
        } catch (error) {
          console.error('Error in handleCellClick:', error.message, error.stack);
          this.showModal('Error', 'An error occurred during the move. Please reset the game.');
        } finally {
          this.isProcessingMove = false;
        }
      }

      nextTurn() {
        try {
          if (!this.activePlayers.includes(true)) {
            this.showModal('Game Over', 'No active players remaining.');
            return;
          }
          let previousPlayer = this.currentPlayer;
          do {
            this.currentPlayer = (this.currentPlayer + 1) % 4;
          } while (!this.activePlayers[this.currentPlayer] && this.activePlayers.includes(true));
          this.turnDisplay.textContent = `🎯 ${this.playerNames[this.currentPlayer]}'s turn (Player ${this.currentPlayer + 1})`;
          this.updateButtonState();
          this.updateRollButtonLabel();
          console.log(`Turn switched from Player ${previousPlayer + 1} (${this.playerNames[previousPlayer]}) to Player ${this.currentPlayer + 1} (${this.playerNames[this.currentPlayer]})`);
        } catch (error) {
          console.error('Error in nextTurn:', error.message, error.stack);
          this.showModal('Error', 'Failed to advance to the next turn. Please reset the game.');
        }
      }

      resetGame() {
        try {
          this.playerPositions = [1, 1, 1, 1];
          this.currentPlayer = 0;
          this.pendingRoll = null;
          this.targetPosition = null;
          this.activePlayers = [false, false, false, false];
          this.playerTokens.forEach(token => token?.remove());
          this.playerTokens = [null, null, null, null];
          this.clearHighlights();
          this.hideDice();
          this.renderPlayer();
          this.card.style.display = 'none';
          this.diceResult.textContent = '';
          this.turnDisplay.textContent = '🎯 Player 1\'s turn';
          this.updateButtonState();
          this.updateRollButtonLabel();
          this.closeVictoryModal();
          console.log('Game reset: Pending Roll and Target Position cleared');
        } catch (error) {
          console.error('Error in resetGame:', error.message, error.stack);
          this.showModal('Error', 'Failed to reset the game. Please refresh the page.');
        }
      }
    }

    document.addEventListener('DOMContentLoaded', function () {
      console.log('DOM loaded, initializing game...');
      try {
        const game = new Game();
        if (game.board) {
          game.initBoard();
          window.game = game;
          game.renderPlayer();
          game.updateButtonState();
        } else {
          console.error('Game initialization failed: board element missing');
          document.getElementById('loading').textContent = 'Error: Board element missing.';
        }
      } catch (error) {
        console.error('Error during initialization:', error.message, error.stack);
        document.getElementById('loading').textContent = 'Error loading game. Please refresh.';
      }
    });
  </script>
</body>
</html>
