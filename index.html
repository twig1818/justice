<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paths of Justice - Web Board Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 28px;
      margin-top: 20px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 4px;
      margin: 20px auto;
      width: max-content;
      position: relative;
      min-height: 470px;
    }
    .cell {
      background-color: lightgray;
      border: 1px solid #999;
      width: 90px;
      height: 90px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      position: relative;
      flex-direction: column;
      cursor: pointer;
    }
    .player {
      border-radius: 50%;
      width: 20px;
      height: 20px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease-in-out;
      z-index: 10;
    }
    .highlight {
      border: 3px solid yellow !important;
      background-color: rgba(255, 255, 0, 0.3) !important;
    }
    .ladder { background-color: #d4fdd4 !important; position: relative; }
    .ladder .ladder-label {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      font-weight: bold;
      color: green;
      text-align: left;
      width: 80px;
      line-height: 12px;
    }
    .chute { background-color: #fdd4d4 !important; position: relative; }
    .chute .chute-label {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      font-weight: bold;
      color: red;
      text-align: left;
      width: 80px;
      line-height: 12px;
    }
    .draw-card { background-color: #d4e3fd !important; position: relative; }
    .draw-card .info-button {
      margin-top: 4px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 10px;
      color: #333;
      padding: 2px 4px;
      font-weight: bold;
    }
    .trouble { background-color: #ffcccb !important; position: relative; }
    .trouble img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .tooltip-content {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      text-align: left;
      padding: 8px;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
      top: 100%;
      left: 0;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      width: 200px;
    }
    .info-tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .chute:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .ladder:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .trouble:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .start { background-color: #a8e6ff !important; }
    .end { background-color: #b9fbc0 !important; }
    .card {
      margin: 20px auto;
      padding: 10px;
      border: 1px solid #333;
      background: #fff;
      max-width: 400px;
      font-size: 14px;
    }
    button {
      margin-top: 10px;
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .player-row {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .info-tooltip {
      position: relative;
      display: inline-block;
    }
    .info-button {
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: none;
    }
    #playerSelection p {
      margin: 10px 0 5px 0;
      font-size: 14px;
    }
    #positionsDisplay {
      margin: 10px auto;
      font-size: 14px;
      max-width: 900px;
      text-align: center;
    }
    #loading {
      margin: 20px;
      font-size: 18px;
      color: #333;
    }
    #gameModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    #gameModalContent {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      text-align: left;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    #gameModalContent h3 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }
    #gameModalContent p {
      margin: 0 0 20px 0;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .modal-buttons button {
      padding: 8px 16px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .modal-button-ok {
      background-color: #2196F3;
      color: white;
    }
    .modal-button-join {
      background-color: #4CAF50;
      color: white;
    }
    .modal-button-cancel {
      background-color: #f44336;
      color: white;
    }
    /* New styles for victory pop-up */
    #victoryModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 200;
      justify-content: center;
      align-items: center;
    }
    #victoryModalContent {
      background-color: #fff;
      padding: 30px;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      border: 3px solid #4CAF50;
    }
    #victoryModalContent h2 {
      margin: 0 0 20px 0;
      font-size: 28px;
      color: #4CAF50;
      text-transform: uppercase;
    }
    #victoryModalContent p {
      font-size: 18px;
      margin: 0 0 20px 0;
      line-height: 1.5;
      color: #333;
    }
    #victoryModalContent img {
      width: 100%;
      max-width: 300px;
      height: auto;
      margin: 20px 0;
      border-radius: 8px;
    }
    .victory-button {
      background-color: #4CAF50;
      color: white;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .victory-button:hover {
      background-color: #45a049;
    }
    #diceDisplay {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    .dice {
      width: 100px;
      height: 100px;
      background-color: white;
      border: 2px solid black;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      padding: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    .dot {
      width: 20px;
      height: 20px;
      background-color: black;
      border-radius: 50%;
      place-self: center;
      display: none;
    }
    .dice-1 .dot:nth-child(1) { display: block; grid-column: 2; grid-row: 2; }
    .dice-2 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-2 .dot:nth-child(2) { display: block; grid-column: 3; grid-row: 3; }
    .dice-3 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-3 .dot:nth-child(2) { display: block; grid-column: 2; grid-row: 2; }
    .dice-3 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 3; }
    .dice-4 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-4 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 3; }
    .dice-4 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 1; }
    .dice-4 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 3; }
    .dice-5 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-5 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 3; }
    .dice-5 .dot:nth-child(3) { display: block; grid-column: 3; grid-row: 1; }
    .dice-5 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 3; }
    .dice-5 .dot:nth-child(5) { display: block; grid-column: 2; grid-row: 2; }
    .dice-6 .dot:nth-child(1) { display: block; grid-column: 1; grid-row: 1; }
    .dice-6 .dot:nth-child(2) { display: block; grid-column: 1; grid-row: 2; }
    .dice-6 .dot:nth-child(3) { display: block; grid-column: 1; grid-row: 3; }
    .dice-6 .dot:nth-child(4) { display: block; grid-column: 3; grid-row: 1; }
    .dice-6 .dot:nth-child(5) { display: block; grid-column: 3; grid-row: 2; }
    .dice-6 .dot:nth-child(6) { display: block; grid-column: 3; grid-row: 3; }
    .start img, .end img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    @media (max-width: 600px) {
      #board {
        grid-template-columns: repeat(10, 60px);
        grid-template-rows: repeat(5, 60px);
        min-height: 310px;
      }
      .cell {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .player {
        width: 15px;
        height: 15px;
      }
      button {
        font-size: 14px;
        padding: 6px 12px;
      }
      #playerSelection p {
        font-size: 12px;
      }
      #positionsDisplay {
        font-size: 12px;
      }
      #gameModalContent {
        padding: 15px;
      }
      #gameModalContent h3 {
        font-size: 16px;
      }
      #gameModalContent p {
        font-size: 12px;
      }
      .modal-buttons button {
        font-size: 12px;
        padding: 6px 12px;
      }
      .chute-label, .ladder-label {
        font-size: 8px;
        width: 50px;
      }
      .draw-card .info-button {
        font-size: 8px;
        padding: 1px 2px;
      }
      .dice {
        width: 60px;
        height: 60px;
        padding: 5px;
      }
      .dot {
        width: 12px;
        height: 12px;
      }
      #victoryModalContent {
        padding: 20px;
        max-width: 90%;
      }
      #victoryModalContent h2 {
        font-size: 20px;
      }
      #victoryModalContent p {
        font-size: 14px;
      }
      #victoryModalContent img {
        max-width: 200px;
      }
      .victory-button {
        padding: 10px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <h1>Paths of Justice</h1>
  <div id="loading">Loading...</div>
  <div style="display: flex; justify-content: center; align-items: flex-start; gap: 40px;">
    <div id="playerSelection" style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">
      <h3>Players</h3>
      <div class="player-row">
        <button onclick="game.joinGame(0)" style="background-color: gold;" aria-label="Join as Jaylen">Join as Jaylen üü°</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Jaylen info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Jaylen ‚Äì He‚Äôs trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(1)" style="background-color: red; color: white;" aria-label="Join as Samantha">Join as Samantha üî¥</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Samantha info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Samantha ‚Äì One mistake and now everyone treats her like a criminal. That kind of label sticks and it‚Äôs messing with her future. (Labeling Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(2)" style="background-color: blue; color: white;" aria-label="Join as Marcus">Join as Marcus üîµ</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Marcus info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Marcus ‚Äì All his friends are doing it, and that‚Äôs how he‚Äôs learning what‚Äôs ‚Äúnormal.‚Äù He‚Äôs picking up habits from the people around him. (Social Learning Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(3)" style="background-color: green; color: white;" aria-label="Join as Elena">Join as Elena üü¢</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Elena info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Elena ‚Äì She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)
          </div>
        </div>
      </div>
      <p id="turnDisplay">üéØ Player 1's turn</p>
      <p id="diceResult"></p>
      <button id="rollDiceButton" onclick="game.rollDice()" aria-label="Roll the dice for current player">Player 1 Roll Dice</button>
      <button onclick="game.resetGame()" aria-label="Start over">Start Over</button>
    </div>
    <div>
      <div id="board" role="grid" aria-live="polite"></div>
      <p id="positionsDisplay">Player positions: <span id="positions">No players</span></p>
    </div>
  </div>
  <div id="diceDisplay">
    <div class="dice">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  <div style="margin-top: 20px;">
    <div class="card" id="card" style="display:none;" role="alert"></div>
  </div>
  <div id="gameModal" role="dialog" aria-labelledby="gameModalTitle" aria-modal="true">
    <div id="gameModalContent">
      <h3 id="gameModalTitle"></h3>
      <p id="gameModalDescription"></p>
      <div class="modal-buttons" id="gameModalButtons"></div>
    </div>
  </div>
  <!-- New victory modal -->
  <div id="victoryModal" role="dialog" aria-labelledby="victoryModalTitle" aria-modal="true">
    <div id="victoryModalContent">
      <h2 id="victoryModalTitle"></h2>
      <p id="victoryModalDescription"></p>
      <img src="https://media.giphy.com/media/xUOwFUnsoHbFLn16eY/giphy.gif" alt="Continue Your Journey GIF">
      <button class="victory-button" onclick="game.closeVictoryModal()" aria-label="Continue">Continue</button>
    </div>
  </div>
  <script>
    class Game {
      constructor() {
        console.log('Game constructor called');
        this.board = document.getElementById('board');
        if (!this.board) {
          console.error('Board element not found!');
          this.showModal('Error', 'Game board not found. Please check the HTML.');
          return;
        }
        this.playerPositions = [1, 1, 1, 1];
        this.currentPlayer = 0;
        this.pendingRoll = null;
        this.targetPosition = null;
        this.activePlayers = [false, false, false, false];
        this.playerColors = ['gold', 'red', 'blue', 'green'];
        this.playerTextColors = ['black', 'white', 'white', 'white'];
        this.playerNames = ['Jaylen', 'Samantha', 'Marcus', 'Elena'];
        this.playerDescriptions = [
          'Jaylen ‚Äì He‚Äôs trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)',
          'Samantha ‚Äì One mistake and now everyone treats her like a criminal. That kind of label sticks and it‚Äôs messing with her future. (Labeling Theory)',
          'Marcus ‚Äì All his friends are doing it, and that‚Äôs how he‚Äôs learning what‚Äôs ‚Äúnormal.‚Äù He‚Äôs picking up habits from the people around him. (Social Learning Theory)',
          'Elena ‚Äì She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)'
        ];
        this.positionsDisplay = document.getElementById('positions');
        this.turnDisplay = document.getElementById('turnDisplay');
        this.diceResult = document.getElementById('diceResult');
        this.diceDisplay = document.getElementById('diceDisplay');
        this.card = document.getElementById('card');
        this.rollButton = document.getElementById('rollDiceButton');
        this.cells = {};
        this.playerTokens = [null, null, null, null];
        this.cellSize = 94;
        this.ladders = {
          4: { to: 18, label: "Strain Theory Ladder to 18", message: "üü¢ Strain Theory: You found a mentor who helped you overcome life's pressures‚Äîclimb up to 18!" },
          11: { to: 26, label: "Labeling Theory Ladder to 26", message: "üü¢ Labeling Theory: You worked hard to break free from a negative label and gained support‚Äîclimb up to 26!" },
          29: { to: 39, label: "Social Learning Ladder to 39", message: "üü¢ Social Learning Theory: You learned positive habits from a role model‚Äîclimb up to 39!" },
          42: { to: 48, label: "Conflict Theory Ladder to 48", message: "üü¢ Conflict Theory: You advocated for change and gained allies in the system‚Äîclimb up to 48!" }
        };
        this.chutes = {
          25: { to: 14, label: "Strain Theory Chute to 14", message: "üî¥ Strain Theory: You felt overwhelmed by life's pressures and made a desperate choice to get ahead. It backfired‚Äîslide down to 14!" },
          30: { to: 20, label: "Labeling Theory Chute to 20", message: "üî¥ Labeling Theory: Society labeled you as a troublemaker after a small mistake, and the stigma made you slip up again‚Äîslide down to 20!" },
          40: { to: 28, label: "Social Learning Chute to 28", message: "üî¥ Social Learning Theory: You copied a risky behavior from those around you, thinking it was okay. Wrong move‚Äîslide down to 28!" },
          47: { to: 35, label: "Conflict Theory Chute to 35", message: "üî¥ Conflict Theory: The system treated you unfairly because of your background, setting you up to fail‚Äîslide down to 35!" }
        };
        this.troubleSlots = {
          17: { to: 1, message: "üî¥ Social Learning Theory: You saw your friends spray painting and thought it was okay, but you got caught! Go back to the start line." },
          31: { to: 1, message: "üî¥ Labeling Theory: You were labeled a troublemaker after spray painting, leading to more trouble! Go back to the start line." }
        };
        this.cardPool = [
          { theory: "Strain Theory", text: "A mentor helps you manage stress from life's pressures. Move forward 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 3); } },
          { theory: "Strain Theory", text: "You secure a part-time job to ease financial strain. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Strain Theory", text: "The pressure to succeed leads you to a risky decision. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Strain Theory", text: "Financial strain causes you to miss an opportunity. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Labeling Theory", text: "You prove the negative labels wrong and gain community support. Move forward 4 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 4); } },
          { theory: "Labeling Theory", text: "A teacher sees your potential beyond the labels. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Labeling Theory", text: "Society's labels make you doubt yourself, causing a setback. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Labeling Theory", text: "A false label leads to unfair treatment. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Social Learning Theory", text: "You learn a valuable skill from a positive role model. Move forward 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 3); } },
          { theory: "Social Learning Theory", text: "A friend inspires you to make better choices. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Social Learning Theory", text: "You pick up a bad habit from peers. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Social Learning Theory", text: "Negative influences lead you astray. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Conflict Theory", text: "You organize a protest and gain allies against an unfair system. Move forward 4 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 4); } },
          { theory: "Conflict Theory", text: "A community leader helps you navigate systemic barriers. Move forward 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 2); } },
          { theory: "Conflict Theory", text: "Systemic inequality blocks your progress. Move back 3 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 3); } },
          { theory: "Conflict Theory", text: "Unfair treatment by authorities sets you back. Move back 2 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 2); } },
          { theory: "Strain Theory", text: "You join a community program that helps you cope with life‚Äôs pressures, giving you a major boost toward your goals. Move forward 6 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 6); } },
          { theory: "Labeling Theory", text: "A past label resurfaces, causing authorities to unfairly target you again. Move back 5 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.max(1, game.playerPositions[game.currentPlayer] - 5); } },
          { theory: "Conflict Theory", text: "You lead a movement against systemic inequality, gaining widespread support and momentum. Move forward 7 spaces.", effect: (game) => { game.playerPositions[game.currentPlayer] = Math.min(50, game.playerPositions[game.currentPlayer] + 7); } }
        ];
        this.cardCells = [6, 10, 15, 19, 23, 28, 33, 37, 48];
        this.currentJoinIndex = null;
        this.isProcessingMove = false;
        this.initModalElements();
        this.setupEventListeners();
        this.updateRollButtonLabel();
      }

      initModalElements() {
        console.log('Initializing modal elements...');
        this.gameModal = document.getElementById('gameModal');
        this.gameModalTitle = document.getElementById('gameModalTitle');
        this.gameModalDescription = document.getElementById('gameModalDescription');
        this.gameModalButtons = document.getElementById('gameModalButtons');
        this.victoryModal = document.getElementById('victoryModal');
        this.victoryModalTitle = document.getElementById('victoryModalTitle');
        this.victoryModalDescription = document.getElementById('victoryModalDescription');
        if (!this.gameModal || !this.gameModalTitle || !this.gameModalDescription || !this.gameModalButtons ||
            !this.victoryModal || !this.victoryModalTitle || !this.victoryModalDescription) {
          console.error('Modal elements not found!');
          document.getElementById('loading').textContent = 'Error: Modal elements not found.';
        }
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.gameModal && this.gameModal.style.display === 'flex') {
            this.gameModal.style.display = 'none';
            this.currentJoinIndex = null;
          }
          if (e.key === 'Escape' && this.victoryModal && this.victoryModal.style.display === 'flex') {
            this.closeVictoryModal();
          }
        });

        if (this.gameModal) {
          this.gameModal.addEventListener('click', (e) => {
            if (e.target === this.gameModal) {
              this.gameModal.style.display = 'none';
              this.currentJoinIndex = null;
            }
          });
        }

        if (this.victoryModal) {
          this.victoryModal.addEventListener('click', (e) => {
            if (e.target === this.victoryModal) {
              this.closeVictoryModal();
            }
          });
        }
      }

      showModal(title, message, buttons = [{ text: 'OK', class: 'modal-button-ok', onClick: () => this.gameModal.style.display = 'none' }]) {
        if (!this.gameModal || !this.gameModalTitle || !this.gameModalDescription || !this.gameModalButtons) {
          console.error('Cannot show modal: modal elements not initialized');
          document.getElementById('loading').textContent = 'Error: Cannot display modal.';
          return;
        }
        this.gameModalTitle.textContent = title;
        this.gameModalDescription.textContent = message;
        this.gameModalButtons.innerHTML = '';

        buttons.forEach(button => {
          const btn = document.createElement('button');
          btn.textContent = button.text;
          btn.className = button.class;
          btn.setAttribute('aria-label', button.text);
          btn.addEventListener('click', () => {
            button.onClick();
          });
          this.gameModalButtons.appendChild(btn);
        });

        this.gameModal.style.display = 'flex';
        this.gameModalButtons.querySelector('button').focus();
      }

      showVictoryModal(playerName) {
        if (!this.victoryModal || !this.victoryModalTitle || !this.victoryModalDescription) {
          console.error('Cannot show victory modal: modal elements not initialized');
          document.getElementById('loading').textContent = 'Error: Cannot display victory modal.';
          return;
        }
        this.victoryModalTitle.textContent = `${playerName} Wins!`;
        this.victoryModalDescription.textContent = 'You have won the game, but your journey is up to you. Continue your journey.';
        this.victoryModal.style.display = 'flex';
        this.victoryModal.querySelector('.victory-button').focus();
      }

      closeVictoryModal() {
        if (this.victoryModal) {
          this.victoryModal.style.display = 'none';
        }
      }

      initBoard() {
        console.log('Initializing board...');
        try {
          document.getElementById('loading').style.display = 'none';
          this.board.innerHTML = '';
          this.cells = {};

          for (let i = 1; i <= 50; i++) {
            console.log(`Creating cell ${i}`);
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${i}`;
            cell.setAttribute('role', 'gridcell');
            const troubleMessage = this.troubleSlots[i] ? `, ${this.troubleSlots[i].message}` : '';
            cell.setAttribute('aria-label', `Cell ${i}${this.ladders[i] ? ', ladder' : ''}${this.chutes[i] ? ', chute' : ''}${this.cardCells.includes(i) ? ', draw card' : ''}${this.troubleSlots[i] ? ', trouble' + troubleMessage : ''}`);
            cell.tabIndex = 0;
            cell.dataset.position = i;
            cell.removeEventListener('click', this.handleCellClickBound);
            cell.addEventListener('click', () => this.handleCellClick(i));
            this.cells[i] = cell;

            if (i === 1) {
              cell.classList.add('start');
              cell.innerHTML = `<img src="https://media.giphy.com/media/27njMqCBPc2SQ/giphy.gif" alt="Start Line">`;
            } else if (i === 50) {
              cell.classList.add('end');
              cell.innerHTML = `<img src="https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif" alt="Finish Line">`;
            } else if (i === 17 || i === 31) {
              cell.classList.add('trouble');
              const troubleData = this.troubleSlots[i];
              cell.innerHTML = `<img src="https://media.giphy.com/media/4GMtanwbPY0xSpy2V5/giphy.gif" alt="Trouble: Spray Paint">`;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = troubleData.message;
              cell.appendChild(tooltip);
            } else {
              cell.innerHTML = `<div>${i}</div>`;
            }

            if (this.ladders[i]) {
              cell.classList.add('ladder');
              const ladderData = this.ladders[i];
              const label = document.createElement('div');
              label.className = 'ladder-label';
              label.textContent = ladderData.label;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = ladderData.message;
              cell.appendChild(label);
              cell.appendChild(tooltip);
            }
            if (this.chutes[i]) {
              cell.classList.add('chute');
              const chuteData = this.chutes[i];
              const label = document.createElement('div');
              label.className = 'chute-label';
              label.textContent = chuteData.label;
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = chuteData.message;
              cell.appendChild(label);
              cell.appendChild(tooltip);
            }
            if (this.cardCells.includes(i)) {
              cell.classList.add('draw-card');
              const wrapper = document.createElement('div');
              wrapper.className = 'info-tooltip';
              const infoButton = document.createElement('button');
              infoButton.className = 'info-button';
              infoButton.textContent = 'Draw a Card';
              infoButton.setAttribute('aria-label', `Card info for cell ${i}`);
              const tooltip = document.createElement('div');
              tooltip.className = 'tooltip-content';
              tooltip.textContent = 'Draw a Card';
              wrapper.appendChild(infoButton);
              wrapper.appendChild(tooltip);
              cell.appendChild(wrapper);
            }
            this.board.appendChild(cell);
          }
        } catch (error) {
          console.error('Error in initBoard:', error.message, error.stack);
          document.getElementById('loading').textContent = 'Error: Failed to initialize the game board.';
          this.showModal('Error', 'Failed to initialize the game board. Please refresh the page.');
        }
      }

      drawRandomCard() {
        const randomIndex = Math.floor(Math.random() * this.cardPool.length);
        return this.cardPool[randomIndex];
      }

      getCellCoordinates(position) {
        const row = Math.floor((position - 1) / 10);
        const col = (position - 1) % 10;
        const x = col * this.cellSize;
        const y = row * this.cellSize;
        return { x, y };
      }

      getTokenOffset(playerIndex, position) {
        const playersAtPosition = this.playerPositions
          .map((pos, idx) => (this.activePlayers[idx] && pos === position ? idx : -1))
          .filter(idx => idx !== -1);
        const playerCount = playersAtPosition.length;
        if (playerCount <= 1) return 0;

        const indexInCell = playersAtPosition.indexOf(playerIndex);
        const offsetStep = window.innerWidth <= 600 ? 10 : 15;
        return (indexInCell - (playerCount - 1) / 2) * offsetStep;
      }

      animateToken(playerIndex, fromPos, toPos) {
        return new Promise(resolve => {
          const token = this.playerTokens[playerIndex];
          if (!token || fromPos === toPos) {
            resolve();
            return;
          }
          this.cells[toPos].appendChild(token);
          const offset = this.getTokenOffset(playerIndex, toPos);
          token.style.transform = `translate(-50%, -50%) translateX(${offset}px)`;
          setTimeout(resolve, 300);
        });
      }

      async renderPlayer() {
        try {
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index] && !this.playerTokens[index]) {
              const token = document.createElement('div');
              token.className = 'player';
              token.style.backgroundColor = this.playerColors[index];
              token.title = `${this.playerNames[index]} (Player ${index + 1})`;
              token.setAttribute('aria-label', `${this.playerNames[index]} at position ${pos}`);
              this.cells[pos].appendChild(token);
              this.playerTokens[index] = token;
            }
          });

          let positionsText = '';
          this.playerPositions.forEach((pos, index) => {
            if (this.activePlayers[index]) {
              const token = this.playerTokens[index];
              if (token && token.parentNode !== this.cells[pos]) {
                this.cells[pos].appendChild(token);
              }
              const offset = this.getTokenOffset(index, pos);
              token.style.transform = `translate(-50%, -50%) translateX(${offset}px)`;
              positionsText += `${this.playerNames[index]}: ${pos} | `;
            }
          });
          this.positionsDisplay.textContent = positionsText ? positionsText.slice(0, -3) : 'No players';
        } catch (error) {
          console.error('Error in renderPlayer:', error.message, error.stack);
          this.showModal('Error', 'Failed to render players. Please reset the game.');
        }
      }

      updateButtonState() {
        const hasPlayers = this.activePlayers.includes(true);
        this.rollButton.disabled = !hasPlayers;
      }

      updateRollButtonLabel() {
        if (this.activePlayers[this.currentPlayer]) {
          this.rollButton.textContent = `${this.playerNames[this.currentPlayer]} Roll Dice`;
          this.rollButton.setAttribute('aria-label', `Roll the dice for ${this.playerNames[this.currentPlayer]}`);
          this.rollButton.style.backgroundColor = this.playerColors[this.currentPlayer];
          this.rollButton.style.color = this.playerTextColors[this.currentPlayer];
        } else {
          this.rollButton.textContent = 'Player Roll Dice';
          this.rollButton.setAttribute('aria-label', 'Roll the dice for current player');
          this.rollButton.style.backgroundColor = '';
          this.rollButton.style.color = '';
        }
      }

      joinGame(playerIndex) {
        try {
          if (this.activePlayers[playerIndex]) {
            this.showModal('Notice', `${this.playerNames[playerIndex]} has already joined.`);
            return;
          }

          this.currentJoinIndex = playerIndex;
          this.showModal(
            `${this.playerNames[playerIndex]}'s Profile`,
            this.playerDescriptions[playerIndex],
            [
              {
                text: 'Cancel',
                class: 'modal-button-cancel',
                onClick: () => {
                  this.gameModal.style.display = 'none';
                  this.currentJoinIndex = null;
                }
              },
              {
                text: 'Join',
                class: 'modal-button-join',
                onClick: () => {
                  this.activePlayers[playerIndex] = true;
                  this.renderPlayer();
                  this.updateButtonState();
                  if (this.currentPlayer === playerIndex && !this.gameModal.style.display = 'none';
                  this.currentJoinIndex = null;
                }
              }
            ]
          );
        } catch (error) {
          console.error('Error in joinGame:', error.message, error.stack);
          this.showModal('Error', 'Failed to join the game. Please refresh the page.');
        }
      }

      clearHighlights() {
        Object.values(this.cells).forEach(cell => {
          cell.classList.remove('highlight');
        });
      }

      highlightTargetCell(position) {
        this.clearHighlights();
        if (this.cells[position]) {
          this.cells[position].classList.add('highlight');
        }
      }

      showDice(roll) {
        const diceElement = this.diceDisplay.querySelector('.dice');
        diceElement.className = 'dice';
        diceElement.classList.add(`dice-${roll}`);
        this.diceDisplay.style.display = 'block';
        setTimeout(() => {
          this.diceDisplay.style.opacity = '1';
        }, 10);
      }

      hideDice() {
        this.diceDisplay.style.opacity = '0';
        setTimeout(() => {
          this.diceDisplay.style.display = 'none';
        }, 500);
      }

      async rollDice() {
        try {
          if (!this.activePlayers.includes(true)) {
            this.showModal('Notice', 'No players have joined the game!');
            return;
          }
          this.card.style.display = 'none';
          this.hideDice();
          const roll = Math.floor(Math.random() * 6) + 1;
          this.pendingRoll = roll;
          this.showDice(roll);
          await new Promise(resolve => setTimeout(resolve, 2000));
          this.diceResult.textContent = `Click on the highlighted cell to move!`;
          const currentPos = this.playerPositions[this.currentPlayer];
          this.targetPosition = Math.min(50, currentPos + roll);
          this.highlightTargetCell(this.targetPosition);
          console.log(`Rolled dice: ${roll}, Current Position: ${currentPos}, Target Position: ${this.targetPosition}, Pending Roll: ${this.pendingRoll}`);
        } catch (error) {
          console.error('Error in rollDice:', error.message, error.stack);
          this.showModal('Error', 'Failed to roll the dice. Please reset the game.');
        }
      }

      async handleCellClick(position) {
        console.log(`handleCellClick called with position: ${position}, Pending Roll: ${this.pendingRoll}, Target Position: ${this.targetPosition}`);
        
        if (this.isProcessingMove) {
          console.log('Move is already being processed, ignoring click');
          return;
        }

        if (this.pendingRoll === null) {
          console.log('Pending roll is null, showing "Please roll the dice first!" message');
          this.showModal('Notice', 'Please roll the dice first!');
          return;
        }

        if (position !== this.targetPosition) {
          console.log(`Clicked position ${position} does not match target position ${this.targetPosition}`);
          this.showModal('Notice', `You must move to cell ${this.targetPosition}!`);
          return;
        }

        this.isProcessingMove = true;
        try {
          console.log(`Player ${this.currentPlayer + 1} clicked cell ${position}`);
          
          const currentPos = this.playerPositions[this.currentPlayer];
          let nextPos = position;

          await this.animateToken(this.currentPlayer, currentPos, nextPos);
          this.playerPositions[this.currentPlayer] = nextPos;

          if (this.ladders[nextPos]) {
            const ladderData = this.ladders[nextPos];
            const ladderPos = ladderData.to;
            this.showModal('Ladder!', `${ladderData.message}\nMoving to position ${ladderPos}!`);
            await this.animateToken(this.currentPlayer, nextPos, ladderPos);
            nextPos = ladderPos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.chutes[nextPos]) {
            const chuteData = this.chutes[nextPos];
            const chutePos = chuteData.to;
            this.showModal('Chute!', `${chuteData.message}\nMoving to position ${chutePos}!`);
            await this.animateToken(this.currentPlayer, nextPos, chutePos);
            nextPos = chutePos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.cardCells.includes(nextPos)) {
            const cardData = this.drawRandomCard();
            console.log(`Drew card at position ${nextPos}: ${cardData.text}`);
            const prevPos = this.playerPositions[this.currentPlayer];
            cardData.effect(this);
            const newPos = this.playerPositions[this.currentPlayer];
            console.log(`After card effect, Player ${this.currentPlayer + 1} moved from ${nextPos} to ${newPos}`);
            
            const displayText = `${cardData.theory}: ${cardData.text}`;
            this.showModal('Action Card', `${displayText}\nYou moved to position ${newPos}!`);

            if (newPos !== nextPos) {
              await this.animateToken(this.currentPlayer, nextPos, newPos);
              nextPos = newPos;
              this.playerPositions[this.currentPlayer] = nextPos;
            } else {
              console.log(`No position change after card effect, proceeding`);
              await new Promise(resolve => setTimeout(resolve, 300));
            }
            this.card.textContent = displayText;
            this.card.style.display = 'block';
          } else {
            this.card.style.display = 'none';
          }

          if (this.troubleSlots[nextPos]) {
            const troubleData = this.troubleSlots[nextPos];
            const troublePos = troubleData.to;
            this.showModal('Trouble!', `${troubleData.message}\nMoving to position ${troublePos}!`);
            await this.animateToken(this.currentPlayer, nextPos, troublePos);
            nextPos = troublePos;
            this.playerPositions[this.currentPlayer] = nextPos;
          }

          if (this.playerPositions[this.currentPlayer] >= 50) {
            this.showVictoryModal(this.playerNames[this.currentPlayer]);
            this.playerTokens[this.currentPlayer].remove();
            this.playerTokens[this.currentPlayer] = null;
            this.activePlayers[this.currentPlayer] = false;
            await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to ensure modal displays
            if (!this.activePlayers.includes(true)) {
              this.showModal('Game Over', 'Game Over! All players have finished.', [
                {
                  text: 'OK',
                  class: 'modal-button-ok',
                  onClick: () => {
                    this.gameModal.style.display = 'none';
                    this.resetGame();
                  }
                }
              ]);
              return;
            }
          }

          await this.renderPlayer();
          this.pendingRoll = null;
          this.targetPosition = null;
          this.hideDice();
          this.clearHighlights();
          this.diceResult.textContent = `üé≤ Rolled: --`;
          console.log('After move, reset Pending Roll and Target Position');
          this.nextTurn();
        } catch (error) {
          console.error('Error in handleCellClick:', error.message, error.stack);
          this.showModal('Error', 'An error occurred during the move. Please reset the game.');
        } finally {
          this.isProcessingMove = false;
        }
      }

      nextTurn() {
        try {
          if (!this.activePlayers.includes(true)) {
            this.showModal('Game Over', 'No active players remaining.');
            return;
          }
          let previousPlayer = this.currentPlayer;
          do {
            this.currentPlayer = (this.currentPlayer + 1) % 4;
          } while (!this.activePlayers[this.currentPlayer] && this.activePlayers.includes(true));
          this.turnDisplay.textContent = `üéØ ${this.playerNames[this.currentPlayer]}'s turn (Player ${this.currentPlayer + 1})`;
          this.updateButtonState();
          this.updateRollButtonLabel();
          console.log(`Turn switched from Player ${previousPlayer + 1} (${this.playerNames[previousPlayer]}) to Player ${this.currentPlayer + 1} (${this.playerNames[this.currentPlayer]})`);
        } catch (error) {
          console.error('Error in nextTurn:', error.message, error.stack);
          this.showModal('Error', 'Failed to advance to the next turn. Please reset the game.');
        }
      }

      resetGame() {
        try {
          this.playerPositions = [1, 1, 1, 1];
          this.currentPlayer = 0;
          this.pendingRoll = null;
          this.targetPosition = null;
          this.activePlayers = [false, false, false, false];
          this.playerTokens.forEach(token => token?.remove());
          this.playerTokens = [null, null, null, null];
          this.clearHighlights();
          this.hideDice();
          this.renderPlayer();
          this.card.style.display = 'none';
          this.diceResult.textContent = '';
          this.turnDisplay.textContent = 'üéØ Player 1\'s turn';
          this.updateButtonState();
          this.updateRollButtonLabel();
          this.closeVictoryModal();
          console.log('Game reset: Pending Roll and Target Position cleared');
        } catch (error) {
          console.error('Error in resetGame:', error.message, error.stack);
          this.showModal('Error', 'Failed to reset the game. Please refresh the page.');
        }
      }
    }

    document.addEventListener('DOMContentLoaded', function () {
      console.log('DOM loaded, initializing game...');
      try {
        const game = new Game();
        if (game.board) {
          game.initBoard();
          window.game = game;
          game.renderPlayer();
          game.updateButtonState();
        } else {
          console.error('Game initialization failed: board element missing');
          document.getElementById('loading').textContent = 'Error: Board element missing.';
        }
      } catch (error) {
        console.error('Error during initialization:', error.message, error.stack);
        document.getElementById('loading').textContent = 'Error loading game. Please refresh.';
      }
    });
  </script>
</body>
</html>
