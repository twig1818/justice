<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paths of Justice - Web Board Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 28px;
      margin-top: 20px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 4px;
      margin: 20px auto;
      width: max-content;
      position: relative;
    }
    .cell {
      background-color: lightgray;
      border: 1px solid #999;
      width: 90px;
      height: 90px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      position: relative;
      flex-direction: column;
      cursor: pointer;
    }
    .player {
      border-radius: 50%;
      width: 20px;
      height: 20px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease-in-out;
      z-index: 10;
    }
    .ladder { background-color: #d4fdd4 !important; }
    .ladder::after {
      content: "üü¢ Good Choice! Move Up";
      position: absolute;
      font-size: 10px;
      bottom: 2px;
      left: 2px;
      color: green;
    }
    .chute { background-color: #fdd4d4 !important; }
    .chute::after {
      content: "üî¥ Bad Choice! Move Down";
      position: absolute;
      font-size: 10px;
      bottom: 2px;
      left: 2px;
      color: red;
    }
    .draw-card { background-color: #d4e3fd !important; position: relative; }
    .draw-card .info-button {
      margin-top: 4px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
    .tooltip-content {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      text-align: left;
      padding: 8px;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
      top: 100%;
      left: 0;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      width: 200px;
    }
    .info-tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }
    .start { background-color: #a8e6ff !important; font-weight: bold; }
    .end { background-color: #b9fbc0 !important; font-weight: bold; }
    .card {
      margin: 20px auto;
      padding: 10px;
      border: 1px solid #333;
      background: #fff;
      max-width: 400px;
      font-size: 14px;
    }
    button {
      margin-top: 10px;
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .player-row {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .info-tooltip {
      position: relative;
      display: inline-block;
    }
    .info-button {
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: none;
    }
    @media (max-width: 600px) {
      #board {
        grid-template-columns: repeat(10, 60px);
        grid-template-rows: repeat(5, 60px);
      }
      .cell {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .player {
        width: 15px;
        height: 15px;
      }
      button {
        font-size: 14px;
        padding: 6px 12px;
      }
    }
  </style>
</head>
<body>
  <h1>Paths of Justice</h1>
  <div style="display: flex; justify-content: center; align-items: flex-start; gap: 40px;">
    <div id="playerSelection" style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">
      <h3>Players</h3>
      <div class="player-row">
        <button onclick="game.joinGame(0)" style="background-color: gold;" aria-label="Join as Jaylen">Join as Jaylen üü°</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Jaylen info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Jaylen ‚Äì He‚Äôs trying to do the right thing but life keeps throwing him curveballs. He might make risky choices just to survive. (Strain Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(1)" style="background-color: red; color: white;" aria-label="Join as Samantha">Join as Samantha üî¥</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Samantha info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Samantha ‚Äì One mistake and now everyone treats her like a criminal. That kind of label sticks and it‚Äôs messing with her future. (Labeling Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(2)" style="background-color: blue; color: white;" aria-label="Join as Marcus">Join as Marcus üîµ</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Marcus info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Marcus ‚Äì All his friends are doing it, and that‚Äôs how he‚Äôs learning what‚Äôs ‚Äúnormal.‚Äù He‚Äôs picking up habits from the people around him. (Social Learning Theory)
          </div>
        </div>
      </div>
      <div class="player-row">
        <button onclick="game.joinGame(3)" style="background-color: green; color: white;" aria-label="Join as Elena">Join as Elena üü¢</button>
        <div class="info-tooltip">
          <button class="info-button" aria-label="Elena info">‚ÑπÔ∏è</button>
          <div class="tooltip-content">
            Elena ‚Äì She sees how unfair the system is, especially for people who look like her. She wants change but faces constant obstacles. (Conflict Theory)
          </div>
        </div>
      </div>
      <button onclick="game.resetGame()" aria-label="Start over">Start Over</button>
    </div>
    <div>
      <div id="board" role="grid"></div>
    </div>
  </div>
  <div style="margin-top: 20px;">
    <p>Player positions: <span id="positions">No players</span></p>
    <p id="turnDisplay">üéØ Player 1's turn</p>
    <p id="diceResult"></p>
    <button onclick="game.rollDice()" aria-label="Roll the dice">Roll Dice</button>
    <button onclick="game.movePlayer()" aria-label="Move player">Move Player</button>
    <div class="card" id="card" style="display:none;" role="alert"></div>
  </div>
  <script>
    class Game {
      constructor() {
        this.playerPositions = [1, 1, 1, 1];
        this.currentPlayer = 0;
        this.pendingRoll = null;
        this.activePlayers = [false, false, false, false];
        this.playerColors = ['gold', 'red', 'blue', 'green'];
        this.playerNames = ['Jaylen', 'Samantha', 'Marcus', 'Elena'];
        this.board = document.getElementById('board');
        this.positionsDisplay = document.getElementById('positions');
        this.turnDisplay = document.getElementById('turnDisplay');
        this.diceResult = document.getElementById('diceResult');
        this.card = document.getElementById('card');
        this.rollButton = document.querySelector('button[onclick="game.rollDice()"]');
        this.moveButton = document.querySelector('button[onclick="game.movePlayer()"]');
        this.cells = {};
        this.playerTokens = [null, null, null, null];
        this.cellSize = 94; // Cell width/height (90px + 4px gap)
        this.ladders = { 4: 18, 11: 26, 29: 39 };
        this.chutes = { 22: 11, 36: 17, 45: 31 };
        this.cards = {
          6: { text: "You forgot to pay rent and things got rough. Move back 1 space.", effect: function () { this.playerPositions[this.playerIndex] = Math.max(1, this.playerPositions[this.playerIndex] - 1); } },
          10: { text: "People start calling you a troublemaker. You lose motivation. Go back 3 spaces.", effect: function () { this.playerPositions[this.playerIndex] = Math.max(1, this.playerPositions[this.playerIndex] - 3); } },
          15: { text: "You meet someone who really believes in you. Move ahead 2 spaces.", effect: function () { this.playerPositions[this.playerIndex] = Math.min(50, this.playerPositions[this.playerIndex] + 2); } },
          19: { text: "You got profiled by the police for no reason. Go back to space 10.", effect: function () { this.playerPositions[this.playerIndex] = 10; } },
          23: { text: "You do some community service and gain confidence. Move ahead 1 space.", effect: function () { this.playerPositions[this.playerIndex] = Math.min(50, this.playerPositions[this.playerIndex] + 1); } },
          28: { text: "Your family hits a rough patch. You're distracted. Move back 2.", effect: function () { this.playerPositions[this.playerIndex] = Math.max(1, this.playerPositions[this.playerIndex] - 2); } },
          33: { text: "You're surrounded by bad influences. You slip up. Move back 1.", effect: function () { this.playerPositions[this.playerIndex] = Math.max(1, this.playerPositions[this.playerIndex] - 1); } },
          37: { text: "Your wealthy family gets you out of trouble. Move ahead 4.", effect: function () { this.playerPositions[this.playerIndex] = Math.min(50, this.playerPositions[this.playerIndex] + 4); } },
          42: { text: "You earn a scholarship‚Äîhuge boost! Move ahead 3.", effect: function () { this.playerPositions[this.playerIndex] = Math.min(50, this.playerPositions[this.playerIndex] + 3); } },
          48: { text: "You're blamed for something you didn‚Äôt do. Move back 3.", effect: function () { this.playerPositions[this.playerIndex] = Math.max(1, this.playerPositions[this.playerIndex] - 3); } }
        };
      }

      initBoard() {
        for (let i = 1; i <= 50; i++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.id = `cell-${i}`;
          cell.setAttribute('role', 'gridcell');
          cell.setAttribute('aria-label', `Cell ${i}${this.ladders[i] ? ', ladder' : ''}${this.chutes[i] ? ', chute' : ''}${this.cards[i] ? ', draw card' : ''}`);
          cell.tabIndex = 0;
          this.cells[i] = cell;

          if (i === 1) {
            cell.classList.add('start');
            cell.innerHTML = `<div>1<br>Start Your Future</div>`;
          } else if (i === 50) {
            cell.classList.add('end');
            cell.innerHTML = `<div>50<br>You Made the Right Choices</div>`;
          } else {
            cell.innerHTML = `<div>${i}</div>`;
          }

          if (this.ladders[i]) cell.classList.add('ladder');
          if (this.chutes[i]) cell.classList.add('chute');
          if (this.cards[i]) {
            cell.classList.add('draw-card');
            const wrapper = document.createElement('div');
            wrapper.className = 'info-tooltip';
            const infoButton = document.createElement('button');
            infoButton.className = 'info-button';
            infoButton.textContent = '‚ÑπÔ∏è';
            infoButton.setAttribute('aria-label', `Card info for cell ${i}`);
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip-content';
            tooltip.textContent = this.cards[i].text;
            wrapper.appendChild(infoButton);
            wrapper.appendChild(tooltip);
            cell.appendChild(wrapper);
          }
          this.board.appendChild(cell);
        }
      }

      getCellCoordinates(position) {
        const row = Math.floor((position - 1) / 10);
        const col = (position - 1) % 10;
        const x = col * this.cellSize;
        const y = row * this.cellSize;
        return { x, y };
      }

      animateToken(playerIndex, fromPos, toPos) {
        return new Promise(resolve => {
          const token = this.playerTokens[playerIndex];
          if (!token || fromPos === toPos) return resolve();

          const fromCoords = this.getCellCoordinates(fromPos);
          const toCoords = this.getCellCoordinates(toPos);
          const dx = toCoords.x - fromCoords.x;
          const dy = toCoords.y - fromCoords.y;

          // Apply translation for animation
          token.style.transform = `translate(${dx - 50}%, ${dy - 50}%)`;
          token.addEventListener('transitionend', () => {
            // Move token to new cell
            this.cells[toPos].appendChild(token);
            // Reset transform to center in new cell
            token.style.transform = 'translate(-50%, -50%)';
            resolve();
          }, { once: true });
        });
      }

      async renderPlayer() {
        this.playerPositions.forEach((pos, index) => {
          if (this.activePlayers[index] && !this.playerTokens[index]) {
            const token = document.createElement('div');
            token.className = 'player';
            token.style.backgroundColor = this.playerColors[index];
            token.title = `${this.playerNames[index]} (Player ${index + 1})`;
            token.setAttribute('aria-label', `${this.playerNames[index]} at position ${pos}`);
            this.cells[pos].appendChild(token);
            this.playerTokens[index] = token;
          }
        });

        let positionsText = '';
        this.playerPositions.forEach((pos, index) => {
          if (this.activePlayers[index]) {
            const token = this.playerTokens[index];
            if (token && token.parentNode !== this.cells[pos]) {
              this.cells[pos].appendChild(token);
              token.style.transform = 'translate(-50%, -50%)';
            }
            positionsText += `${this.playerNames[index]}: ${pos} | `;
          }
        });
        this.positionsDisplay.textContent = positionsText ? positionsText.slice(0, -3) : 'No players';
      }

      updateButtonState() {
        const hasPlayers = this.activePlayers.includes(true);
        this.rollButton.disabled = !hasPlayers;
        this.moveButton.disabled = !hasPlayers;
      }

      joinGame(playerIndex) {
        if (this.activePlayers[playerIndex]) {
          alert(`${this.playerNames[playerIndex]} has already joined.`);
          return;
        }
        this.activePlayers[playerIndex] = true;
        alert(`${this.playerNames[playerIndex]} joined the game!`);
        this.renderPlayer();
        this.updateButtonState();
        if (this.currentPlayer === playerIndex && !this.activePlayers[this.currentPlayer]) {
          this.nextTurn();
        }
      }

      rollDice() {
        if (!this.activePlayers.includes(true)) {
          alert('No players have joined the game!');
          return;
        }
        this.card.style.display = 'none';
        const roll = Math.floor(Math.random() * 6) + 1;
        this.pendingRoll = roll;
        this.diceResult.textContent = `üé≤ Rolled: ${roll}`;
      }

      async movePlayer() {
        if (this.pendingRoll === null) {
          alert('Please roll the dice first!');
          return;
        }

        this.moveButton.disabled = true;
        const currentPos = this.playerPositions[this.currentPlayer];
        let nextPos = Math.min(50, currentPos + this.pendingRoll);

        // Animate to rolled position
        await this.animateToken(this.currentPlayer, currentPos, nextPos);
        this.playerPositions[this.currentPlayer] = nextPos;

        // Handle ladder
        if (this.ladders[nextPos]) {
          const ladderPos = this.ladders[nextPos];
          alert('üü¢ You climbed a ladder!');
          await this.animateToken(this.currentPlayer, nextPos, ladderPos);
          nextPos = ladderPos;
          this.playerPositions[this.currentPlayer] = nextPos;
        }
        // Handle chute
        else if (this.chutes[nextPos]) {
          const chutePos = this.chutes[nextPos];
          alert('üî¥ You slid down a chute!');
          await this.animateToken(this.currentPlayer, nextPos, chutePos);
          nextPos = chutePos;
          this.playerPositions[this.currentPlayer] = nextPos;
        }

        // Handle card
        if (this.cards[nextPos]) {
          const cardData = this.cards[nextPos];
          cardData.effect = cardData.effect.bind({ playerIndex: this.currentPlayer, playerPositions: this.playerPositions });
          const prevPos = this.playerPositions[this.currentPlayer];
          cardData.effect();
          const newPos = this.playerPositions[this.currentPlayer];
          if (newPos !== prevPos) {
            await this.animateToken(this.currentPlayer, prevPos, newPos);
          }
          this.card.textContent = cardData.text;
          this.card.style.display = 'block';
        } else {
          this.card.style.display = 'none';
        }

        // Check for win
        if (this.playerPositions[this.currentPlayer] >= 50) {
          alert(`${this.playerNames[this.currentPlayer]} wins!`);
          this.playerTokens[this.currentPlayer].remove();
          this.playerTokens[this.currentPlayer] = null;
          this.activePlayers[this.currentPlayer] = false;
          if (!this.activePlayers.includes(true)) {
            alert('Game Over! All players have finished.');
            this.resetGame();
            this.moveButton.disabled = false;
            return;
          }
        }

        await this.renderPlayer();
        this.pendingRoll = null;
        this.nextTurn();
        this.moveButton.disabled = false;
      }

      nextTurn() {
        do {
          this.currentPlayer = (this.currentPlayer + 1) % 4;
        } while (!this.activePlayers[this.currentPlayer] && this.activePlayers.includes(true));
        this.turnDisplay.textContent = `üéØ ${this.playerNames[this.currentPlayer]}'s turn (Player ${this.currentPlayer + 1})`;
        this.updateButtonState();
      }

      resetGame() {
        this.playerPositions = [1, 1, 1, 1];
        this.currentPlayer = 0;
        this.pendingRoll = null;
        this.activePlayers = [false, false, false, false];
        this.playerTokens.forEach(token => token?.remove());
        this.playerTokens = [null, null, null, null];
        this.renderPlayer();
        this.card.style.display = 'none';
        this.diceResult.textContent = '';
        this.turnDisplay.textContent = 'üéØ Player 1\'s turn';
        this.updateButtonState();
      }
    }

    window.onload = function () {
      const game = new Game();
      game.initBoard();
      window.game = game;
      game.renderPlayer();
      game.updateButtonState();
    };
  </script>
</body>
</html>

